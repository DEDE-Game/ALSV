


EngineInit()
 |--FEngineLoop::Init()
 | |--FEmbeddedCommunication::ForceTick(10);// 强制静默[MinTimeSlice,MaxTimeSlice],单位:ms
 | |--创建Engine
 | |--FEmbeddedCommunication::ForceTick(11)// 强制静默[MinTimeSlice,MaxTimeSlice],单位:ms
 | |--GEngine->ParseCommandline(); //解析命令行参数
 | |--FEmbeddedCommunication::ForceTick(12); // 强制静默[MinTimeSlice,MaxTimeSlice],单位:ms
 | |--FEngineLoop.InitTime() // 初始化时间
 | |--UGameEngine.Init() // 引擎初始化
 | | |--UEngine::Init();
 | | | |--FURL::StaticInit(); // 初始化URL
 | | |--GetGameUserSettings()->LoadSettings();
 | | |--GetGameUserSettings()->ApplyNonResolutionSettings();
 | | |--创建UGameInstance
 | | |--GameInstance->InitializeStandalone();
 | | | |--UGameInstance.Init()
 | | | | |--UGameInstance.ReceiveInit() // preinit的额外设置,引擎默认为空
 | | | | |--App->RegisterConsoleCommandListener(GenericApplication::FOnConsoleCommandListener::CreateUObject(this, &ThisClass::OnConsoleInput));// 注册了命令行回调函数
 | | | | |--FNetDelegates::OnReceivedNetworkEncryptionToken.BindUObject(this, &ThisClass::ReceivedNetworkEncryptionToken);
 | | | | |--FNetDelegates::OnReceivedNetworkEncryptionAck.BindUObject(this, &ThisClass::ReceivedNetworkEncryptionAck);
 | | | | |--FSubsystemCollectionBase.Initialize()
 | | |--创建UGameViewportClient
 | | |--UGameViewportClient.Init()
 | | |--UEngine.GameViewport = ViewportClient
 | | |--GameInstance->GetWorldContext()->GameViewport = ViewportClient;
 | | |--UEngine.bIsInitialized = true
 | |--UEngine.Start() // 引擎初启动
 | | |--UGameEngine::Start()
 | | | |--UGameEngine::Start()
 | | | | |--UGameInstance.StartGameInstance
 | | | | |--加载地图配置,详情参考FURL解析
 | | | | |--Engine->Browse(*WorldContext, URL, Error) // DS端切换地图
 | | | | | |--UEngine.LoadMap()
 | | | | | | |--FCoreUObjectDelegates::PreLoadMap.Broadcast(URL.Map) // 广播加载地图前事件
 | | | | | | |--UEngine.ShutdownWorldNetDriver(WorldContext.World()) // 关闭之前world的netdriver
 | | | | | | |--清理上一个world
 | | | | | | |--UGameInstance.PreloadContentForURL() // 可以在加载Content之前, 做一些处理操作
 | | | | | | |--LoadPackage()// 加载world
 | | | | | | |--NewWorld->SetGameInstance(WorldContext.OwningGameInstance) // 为world设置GameInstance
 | | | | | | |--GWorld = NewWorld; //设置GWorld
 | | | | | | |--WorldContext.SetCurrentWorld(NewWorld); // 将world和WorldContext绑定
 | | | | | | |--WorldContext.World()->WorldType = WorldContext.WorldType; // 设置world的WorldType
 | | | | | | |--WorldContext.World()->AddToRoot(); // 将world加入root,防止gc
 | | | | | | |--WorldContext.World()->InitWorld(); // 初始化world
 | | | | | | |--WorldContext.World()->SetGameMode(URL);; // 初始化World的GameMode
 | | | | | | | |--UWorld.SetGameMode(URL) // 设置World的GameMode
 | | | | | | | | |--AuthorityGameMode = GetGameInstance()->CreateGameModeForURL(InURL, this); // 设置UWorld.AuthorityGameMode
 | | | | | | | | | |--根据配置读取GameMode
 | | | | | | | | | |--UGameInstance.OverrideGameModeClass() //如果有需求,可以在GameInstance中重置GameMode
 | | | | | | | | | |--World->SpawnActor<AGameModeBase>(GameClass, SpawnInfo);// 创建GameMod
 | | | | | | |--WorldContext.World()->Listen(URL) //服务器端进行监听
 | | | | | | | |--UEngine.CreateNamedNetDriver()
 | | | | | | | | |--NetDriver.CreateNetDriver_Local() //根据配置创建了NetDriver
 | | | | | | | |--UNetDriver.SetWorld() // 将NetDriver和World绑定
 | | | | | | | |--UIpNetDriver.InitListen() //监听端口
 | | | | | | | | |--UIpNetDriver.InitBase()
 | | | | | | | | | |--UNetDriver.InitBase()
 | | | | | | | | | | |--UNetDriver.InitConnectionClass()// 加载NetConnectionClass
 | | | | | | | | | | |--ConnectionlessHandler.Reset(nullptr); // 重置 PacketHandler
 | | | | | | | | | | |--// 针对DS, 创建UReplicationDriver, 并且和UIpNetDriver绑定
 | | | | | | | | | | |--SetReplicationDriver(UReplicationDriver::CreateReplicationDriver(this, URL, GetWorld()));
 | | | | | | | | | |-- const int32 BindPort = bInitAsClient ? GetClientPort() : URL.Port; // 获取Port
 | | | | | | | | | |-- // 获取客户端/DS收发buffer大小
 | | | | | | | | | |--const int32 DesiredRecvSize = bInitAsClient ? ClientDesiredSocketReceiveBufferBytes : ServerDesiredSocketReceiveBufferBytes;
 | | | | | | | | | |--const int32 DesiredSendSize = bInitAsClient ? ClientDesiredSocketSendBufferBytes : ServerDesiredSocketSendBufferBytes;
 | | | | | | | | | |--UIpNetDriver.CreateAndBindSocket() //初始化监听端口回调函数
 | | | | | | | | | | |--// 如果是DS, 只能绑定一个, 如果是客户端, 则可以绑定很多个
 | | | | | | | | | | |--UIpNetDriver.CreateSocketForProtocol() // 根据协议类型创建Socket, UE4是UDP
 | | | | | | | | | | | |--SocketSubsystem->CreateUniqueSocket(NAME_DGram, TEXT("Unreal"), ProtocolType) // 设置为IPV4,UDP数据报
 | | | | | | | | | | |--NewSocket->SetReceiveBufferSize() //设置接收buffer大小
 | | | | | | | | | | |--NewSocket->SetSendBufferSize() //设置发送buffer大小
 | | | | | | | | | | |--BindAddr->SetPort(Port); //设置端口号
 | | | | | | | | | | |-- // 如果Port绑定失败,则尝试该端口号后续端口号, 直到成功或者都尝试了一遍为止. 
 | | | | | | | | | | |--int32 BoundPort = SocketSubsystem->BindNextPort(NewSocket.Get(), *BindAddr, MaxPortCountToTry + 1, 1);
 | | | | | | | | | | |--NewSocket->SetNonBlocking() ; //设置非阻塞模式
 | | | | | | | | |--UIpNetDriver.InitConnectionlessHandler() //初始化监听端口回调函数
 | | | | | | | | | |--ConnectionlessHandler = MakeUnique<PacketHandler>(&DDoS); // 创建ConnectionlessHandler
 | | | | | | | | | |--ConnectionlessHandler->Initialize(Handler::Mode::Server, MAX_PACKET_SIZE, true, nullptr, nullptr, NetDriverName);
 | | | | | | | | | |-- // 使用Engine.EngineHandlerComponentFactory创建StatelessConnectHandlerComponent
 | | | | | | | | | |--TSharedPtr<HandlerComponent> NewComponent = ConnectionlessHandler->AddHandler(TEXT("Engine.EngineHandlerComponentFactory(StatelessConnectHandlerComponent)"), true);
 | | | | | | | | | | |-- //解析参数Engine.EngineHandlerComponentFactory(StatelessConnectHandlerComponent)
 | | | | | | | | | | |-- // 使用Engine.EngineHandlerComponentFactory作为class
 | | | | | | | | | | |--UClass* FactoryClass = StaticLoadClass(UHandlerComponentFactory::StaticClass(), nullptr, *ComponentName);
 | | | | | | | | | | |-- // 创建Factory:EngineHandlerComponentFactory
 | | | | | | | | | | |--Factory = NewObject<UHandlerComponentFactory>(GetTransientPackage(), FactoryClass, *SingletonName);
 | | | | | | | | | | |-- // 使用EngineHandlerComponentFactory创建Handle
 | | | | | | | | | | |--ReturnVal = Factory->CreateComponentInstance(ComponentOptions);
 | | | | | | | | | | | |--MakeShareable(new StatelessConnectHandlerComponent); // 创建StatelessConnectHandlerComponent
 | | | | | | | | | |-- // 将新创建的NewComponent设置为StatelessConnectComponent, 以后直接使用
 | | | | | | | | | |--StatelessConnectComponent = StaticCastSharedPtr<StatelessConnectHandlerComponent>(NewComponent);
 | | | | | | | | | |-- // 将StatelessConnectComponent和IpNetDriver关联
 | | | | | | | | | |--StatelessConnectComponent.Pin()->SetDriver(this);
 | | | | | | | | | |--PacketHandler.Initialize() //初始化PacketHandler
 | | | | | | | | | | |--Component->Initialize(); 
 | | | | | | | | | | | |--Handler->HandlerComponentInitialized(this);
 | | | | | | | |--NextSwitchCountdown = NetDriver->ServerTravelPause //设置world的切换延迟时间,给客户端一些时间接收最后的rpc
 | | | | |--UGameInstance.BroadcastOnStart()
 | | | | | |--FWorldDelegates::OnStartGameInstance.Broadcast(this); // 广播OnStartGameInstance事件
 | | | | |
 | | | | |--UGameInstance.OnStart()
 | 




UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--UIpNetDriver.ProcessConnectionlessPacket()
| | |--PacketHandler.IncomingConnectionless()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.IncomingConnectionless()
| | | | | |--StatelessConnectHandlerComponent.ParseHandshakePacket()
| | | | | |--bChallengeSuccess = FMemory::Memcmp(Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0; // 服务器校验客户端发来的Cookie
| | | | | |--LastChallengeSuccessAddress = Address->Clone();
| | | | | |--int16* CurSequence = (int16*)Cookie;
| | | | | |--LastServerSequence = *CurSequence & (MAX_PACKETID - 1); // 初始化ServerSequenceID
| | | | | |--LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1); // 设置ClientSequenceID
| | | | | |--StatelessConnectHandlerComponent.SendChallengeAck()
| | |--StatelessConnect->HasPassedChallenge() //StatelessConnectHandlerComponent.HasPassedChallenge()
| | |--NewObject<UIpConnection>(); // 创建UIpConnection.
| | |--ReturnVal->InitRemoteConnection(..., USOCK_Open);// 初始化UIpConnection. UIpConnection::InitRemoteConnection()
| | | |--UIpConnection.InitBase()
| | | | |--UNetConnection.InitBase()
| | | | | |--UNetConnection.State=USOCK_Open. // 这里设置State为Open,等待客户端发来NMT_Hello时进行状态检测.
| | | | |--UNetConnection.InitSendBuffer() //初始化SendBuffer
| | | | |--UNetConnection.SetClientLoginState(EClientLoginState::LoggingIn) // 设置login状态为LoggingIn
| | | | |--UNetConnection.SetExpectedClientLoginMsgType(NMT_Hello) // 设置期望消息为:NMT_Hello
| | |--UNetDriver.AddClientConnection() //添加到ClientConnections中
| | |--StatelessConnect->ResetChallengeData() //重置LastChallengeSuccessAddress等信息
 
 

UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UIpNetDriver.ProcessConnectionlessPacket()
| | |--PacketHandler.IncomingConnectionless()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.IncomingConnectionless()
| | | | | |--bool bHandshakePacket = !!Packet.ReadBit() && !Packet.IsError();
| | | | | |--StatelessConnectHandlerComponent.SendRestartHandshakeRequest()
| | | | | | |--RestartPacket.WriteBit(bHandshakePacket); // 这里是1
| | | | | | |--RestartPacket.WriteBit(bRestartHandshake);// 这里是1
| | | | | | |--CapHandshakePacket(RestartPacket); // 消息结束符
| | | | | | |--Driver->LowLevelSend(ClientAddress, RestartPacket.GetData(), RestartPacket.GetNumBits(), Traits);




| | | | | |--bChallengeSuccess = FMemory::Memcmp(Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0; // 服务器校验客户端发来的Cookie
| | | | | |--LastChallengeSuccessAddress = Address->Clone();
| | | | | |--int16* CurSequence = (int16*)Cookie;
| | | | | |--LastServerSequence = *CurSequence & (MAX_PACKETID - 1); // 初始化ServerSequenceID
| | | | | |--LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1); // 设置ClientSequenceID
| | | | | |--StatelessConnectHandlerComponent.SendChallengeAck()
| | |--StatelessConnect->HasPassedChallenge() //StatelessConnectHandlerComponent.HasPassedChallenge()
| | |--NewObject<UIpConnection>(); // 创建UIpConnection.
| | |--ReturnVal->InitRemoteConnection(..., USOCK_Open);// 初始化UIpConnection. UIpConnection::InitRemoteConnection()
| | | |--UIpConnection.InitBase()
| | | | |--UNetConnection.InitBase()
| | | | | |--UNetConnection.State=USOCK_Open. // 这里设置State为Open,等待客户端发来NMT_Hello时进行状态检测.
| | | | |--UNetConnection.InitSendBuffer() //初始化SendBuffer
| | | | |--UNetConnection.SetClientLoginState(EClientLoginState::LoggingIn) // 设置login状态为LoggingIn
| | | | |--UNetConnection.SetExpectedClientLoginMsgType(NMT_Hello) // 设置期望消息为:NMT_Hello
| | |--UNetDriver.AddClientConnection() //添加到ClientConnections中
| | |--StatelessConnect->ResetChallengeData() //重置LastChallengeSuccessAddress等信息



// 计算DS当前时间和发送ConnectChallenge时间之差
const double CookieDelta = Driver->GetElapsedTime() - Timestamp;
// 计算发送ConnectChallenge时间和LastSecretUpdateTimestamp的时间之差
const double SecretDelta = Timestamp - LastSecretUpdateTimestamp;
// 从发送ConnectChallenge的时间到现在所间隔的时间必须在MAX_COOKIE_LIFETIME之内
const bool bValidCookieLifetime = CookieDelta >= 0.0 && (MAX_COOKIE_LIFETIME - CookieDelta) > 0.0;
// 如果SecretId==ActiveSecret, 那么SecretDelta一定不会比0小, 如果如果SecretId!=ActiveSecret, SecretDelta一定不会大于0.
const bool bValidSecretIdTimestamp = (SecretId == ActiveSecret) ? (SecretDelta >= 0.0) : (SecretDelta <= 0.0);



客户端接收到RestartHandShake请求
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UNetConnection.ReceivedRawPacket()
| | |--PacketHandler.Incoming()
| | | |--PacketHandler.Incoming_Internal(uint8* Packet, int32 CountBytes, bool bConnectionless, const TSharedPtr<const FInternetAddr>& Address)
| | | | |--PacketHandler::Incoming_Internal(FReceivedPacketView& PacketView)
| | | | | |--StatelessConnectHandlerComponent.Incoming()
| | | | | | |--StatelessConnectHandlerComponent.ParseHandshakePacket() 
| | | | | | | |-- 解析出bRestartHandshake为true, 需要重新握手
| | | | | | |-- // AuthorisedCookie必须不为空
| | | | | | |--bool bValidAuthCookie = FMemory::Memcmp(AuthorisedCookie, ZeroCookie, COOKIE_BYTE_SIZE) != 0;
| | | | | | |-- // 客户端发送最后消息再过10s后, 才能开始重新握手, server可能重发很多次restart
| | | | | | |--bPassedDelayCheck = (CurrentTime - LastClientSendTimestamp) > 10.0;
| | | | | | |-- // 其他条件检测
| | | | | | |--double LastRestartPacketTimeDiff = CurrentTime - LastRestartPacketTimestamp;
| | | | | | |--double LastNetConnPacketTimeDiff = CurrentTime - LastNetConnPacketTime;
| | | | | | |-- // 如果满足条件会设置state为UnInitialized, 并开始握手
| | | | | | |-- SetState(Handler::Component::State::UnInitialized);
| | | | | | |-- NotifyHandshakeBegin();
| | | | | | | |--// 和正常握手不同, 重新握手要将bRestartHandshake设置为true
| | | | | | | |--bRestartHandshake = true;


//堆栈
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UIpNetDriver.ProcessConnectionlessPacket()
| | |--PacketHandler.IncomingConnectionless()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.IncomingConnectionless()
| | | | | |--StatelessConnectHandlerComponent.ParseHandshakePacket()
| | | | | |--FMemory::Memcpy(AuthorisedCookie, OrigCookie, UE_ARRAY_COUNT(AuthorisedCookie));
| | | | | |-- // 重新握手情况下, 后续会使用, 针对重新握手情况, 这里是true
| | | | | |--bRestartedHandshake = bRestartHandshake;
| | | | | |--LastChallengeSuccessAddress = Address->Clone();
| | | | | |--StatelessConnectHandlerComponent.SendChallengeAck()
| | |--StatelessConnect->HasPassedChallenge() 
| | | |--// 提取bRestartedHandshake变量, 用于判断是否是重新握手
| | | |--bOutRestartedHandshake = bRestartedHandshake;
| | | |--判断地址是否是刚才解析成功的地址, 即:LastChallengeSuccessAddress
| | |-- 遍历UNetDriver.ClientConnections中所有connection,检测cookie是否一致.
| | |-- 如果cookie相同, 则直接拿来重新使用.
| | |-- 如果没有找到旧的 则创建新的
| | |--   NewObject<UIpConnection>(); // 创建UIpConnection.
| | |--   ReturnVal->InitRemoteConnection(..., USOCK_Open);// 初始化UIpConnection. UIpConnection::InitRemoteConnection()
| | | |--UIpConnection.InitBase()
| | | | |--UNetConnection.InitBase()
| | | | | |--UNetConnection.State=USOCK_Open. // 这里设置State为Open,等待客户端发来NMT_Hello时进行状态检测.
| | | | |--UNetConnection.InitSendBuffer() //初始化SendBuffer
| | | | |--UNetConnection.SetClientLoginState(EClientLoginState::LoggingIn) // 设置login状态为LoggingIn
| | | | |--UNetConnection.SetExpectedClientLoginMsgType(NMT_Hello) // 设置期望消息为:NMT_Hello
| | |--UNetDriver.AddClientConnection() //添加到ClientConnections中
| | |--StatelessConnect->ResetChallengeData() //重置LastChallengeSuccessAddress等信息

	if (!IsInternalAck() && !bIsReinjectingDelayedPackets)
	{
		if (PacketSimulationSettings.PktIncomingLoss)
		{
			if (FMath::FRand() * 100.f < PacketSimulationSettings.PktIncomingLoss)
			{
				UE_LOG(LogNet, VeryVerbose, TEXT("Dropped incoming packet at %f"), FPlatformTime::Seconds());
				return;
			}

		}
		if (PacketSimulationSettings.PktIncomingLagMin > 0 || PacketSimulationSettings.PktIncomingLagMax > 0)
		{
			// ExtraLagInSec goes from [PktIncomingLagMin, PktIncomingLagMax]
			const double LagVarianceInMS = FMath::FRand() * double(PacketSimulationSettings.PktIncomingLagMax - PacketSimulationSettings.PktIncomingLagMin);
			const double ExtraLagInSec = (double(PacketSimulationSettings.PktIncomingLagMin) + LagVarianceInMS) / 1000.f;

			FDelayedIncomingPacket DelayedPacket;
			DelayedPacket.PacketData = MakeUnique<FBitReader>(Reader);
			DelayedPacket.ReinjectionTime = FPlatformTime::Seconds() + ExtraLagInSec;

			DelayedIncomingPackets.Emplace(MoveTemp(DelayedPacket));

			UE_LOG(LogNet, VeryVerbose, TEXT("Delaying incoming packet for %f seconds"), ExtraLagInSec);
			return;
		}
	}






在下一帧tick时候进行UPendingNetGame的初始化
FEngineLoop.Tick()
--UGameEngine.Tick()    
|--UEngine::TickWorldTravel()    
| |--UEngine.Browse()
| | |--WorldContext.PendingNetGame = NewObject<UPendingNetGame>();
| | |--WorldContext.PendingNetGame->Initialize(URL); //-V595
| | |--WorldContext.PendingNetGame->InitNetDriver(); //-V595
| | | |--GEngine->CreateNamedNetDriver()
| | | |--NetDriver = GEngine->FindNamedNetDriver(this, NAME_PendingNetDriver);
| | | |--NetDriver->InitConnect()
| | | | |--UIpNetDriver::InitBase()
| | | | | |--UNetConnection::InitBase()
| | | | | | |--UNetConnection::SetConnectionId()
| | | | | | |  --UNetConnection::InitHandler()
| | | | | |--UIpNetDriver::CreateAndBindSocket()
| | | | | |--NewSocket->SetReceiveBufferSize();
| | | | | |  --NewSocket->SetSendBufferSize();
| | | | | |--UIpNetDriver::SetSocketAndLocalAddress()
| | | | |--ServerConnection = NewObject<UNetConnection>(GetTransientPackage(), NetConnectionClass);
| | | | |--ServerConnection->InitLocalConnection(this, Socket, ConnectURL, USOCK_Pending);
| | | | |--// 创建ServerConnection中的Channel
| | | | |--UNetDriver::CreateInitialClientChannels()//指定创建客户端Channels
| | | | | |--// 客户端channel的创建类型都是EChannelCreateFlags::OpenedLocally
| | | | | |--ServerConnection->CreateChannelByName(ChannelDef.ChannelName, EChannelCreateFlags::OpenedLocally, ChannelDef.StaticChannelIndex);
| | | | | | |--UChannel* Channel = Driver->GetOrCreateChannelByName(ChName);
| | | | | | |--Channel->Init( this, ChIndex, CreateFlags );
| | | | | | |--OpenChannels.Add(Channel);
| | | |-- // 设置回调函数, 发送成功后, 调用UPendingNetGame::SendInitialJoin
| | | |--ServerConn->Handler->BeginHandshaking()
| | | | |--CurComponent.NotifyHandshakeBegin() //StatelessConnectHandlerComponent::NotifyHandshakeBegin()
| | | | | |--StatelessConnectHandlerComponent::NotifyHandshakeBegin() //拼接HandShake消息
| | | | | | |--ServerConn->Driver->IsNetResourceValid() // 此处返回false, 发送失败.
由于UIpNetDriver.ServerConnection.Socket是nullptr,此处发送失败.


 设置login状态为LoggingIn
SetClientLoginState(EClientLoginState::LoggingIn) 
SetExpectedClientLoginMsgType(NMT_Hello) // 设置期望消息为:NMT_Hello



//DS处理ChallengeResponse,回复ChallengeAck
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UIpNetDriver.ProcessConnectionlessPacket()
| | |--PacketHandler.IncomingConnectionless()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.IncomingConnectionless()
| | | | | |--StatelessConnectHandlerComponent.ParseHandshakePacket()
| | | | | |--bChallengeSuccess = FMemory::Memcmp(Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0; // 服务器校验客户端发来的Cookie
| | | | | |--LastChallengeSuccessAddress = Address->Clone();
| | | | | |--int16* CurSequence = (int16*)Cookie;
| | | | | |--LastServerSequence = *CurSequence & (MAX_PACKETID - 1); // 初始化ServerSequenceID
| | | | | |--LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1); // 设置ClientSequenceID
| | | | | |--StatelessConnectHandlerComponent.SendChallengeAck()
| | |--StatelessConnect->HasPassedChallenge() //StatelessConnectHandlerComponent.HasPassedChallenge()
| | |--NewObject<UIpConnection>(); // 创建UIpConnection.
| | |--ReturnVal->InitRemoteConnection(..., USOCK_Open);// 初始化UIpConnection. UIpConnection::InitRemoteConnection()
| | | |--UIpConnection.InitBase()
| | | | |--UNetConnection.InitBase()
| | | | | |--UNetConnection.State=USOCK_Open. // 这里设置State为Open,等待客户端发来NMT_Hello时进行状态检测.
| | | | |--UNetConnection.InitSendBuffer() //初始化SendBuffer
| | | | |--UNetConnection.SetClientLoginState(EClientLoginState::LoggingIn) // 设置login状态为LoggingIn
| | | | |--UNetConnection.SetExpectedClientLoginMsgType(NMT_Hello) // 设置期望消息为:NMT_Hello
| | |--UNetDriver.AddClientConnection() //添加到ClientConnections中
| | | |--UNetDriver.CreateInitialServerChannels()
| | | | |--//DS在这里创建ServerChannel, 并且Channel的创建类型是EChannelCreateFlags::OpenedLocally
| | | | |--ClientConnection->CreateChannelByName(ChannelDef.ChannelName, EChannelCreateFlags::OpenedLocally, ChannelDef.StaticChannelIndex);
| | |--StatelessConnect->ResetChallengeData() //重置LastChallengeSuccessAddress等信息





UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UNetConnection.ReceivedRawPacket()
| | |--const ProcessedPacket UnProcessedPacket = Handler->Incoming(Data, Count);
| | | |--PacketHandler.Incoming_Internal()
| | | | |--// 填充地址
| | | | |--PacketView.Address = Address;
| | | | |--// 是否是握手包,这里为false
| | | | |--PacketView.Traits.bConnectionlessPacket = bConnectionless;
| | | | |--EIncomingResult Result = Incoming_Internal(PacketView);
| | | | | |-- 这个包刚从Socket接收过来, 是以字节为单位, 经过这里的计算, 可以计算出该包真实bit数量
| | | | | |-- 对这块代码的讲解, 见详述-计算包bit数
| | | | | |--StatelessConnectHandlerComponent.Incoming()
| | | | | | |--首bit不是1, 并且是DS端, 直接将地址情况, 因为LastChallengeSuccessAddress是临时数据, 为了验证PassedChallenge的
| | | | | | |--其实, 连接包走到这里任何实质性修改也不会做的, 该函数主要是在握手期间客户端使用.
| | | | | |--PacketHandler.ReplaceIncomingPacket()
| | | | | | |--将收到的包存储在PacketHandler.IncomingPacket中. 这里还要去掉已经处理的头部.
| | | | | |--// 将处理完成的IncomingPacket存放在PacketView.DataView中, 并且将状态置为ECountUnits::Bits
| | | | | |--PacketView.DataView = {IncomingPacket.GetData(), (int32)IncomingPacket.GetBitsLeft(), ECountUnits::Bits};
| | |--这里还要去掉已经处理过包的尾部, TODO: 为什么呢?
| | |--UNetConnection.ReceivedPacket()
| | | |-- // 处理包自定义的lag和loss(仅用于测试)
| | | |-- // 处理直方图




//UE4网络--详细分析FNetControlMessage<NMT_Hello>::Send
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UNetConnection.ReceivedRawPacket()
| | |--PacketHandler.Incoming_Internal()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.Incoming()
| | | | | |--HandlerComponent.Initialized()
| | | | | | |--PacketHandler.HandlerComponentInitialized()
| | | | | | | |--PacketHandler.HandlerInitialized()
| | | | | | | | |--// 详情查看:UE4网络---UPendingNetGame
| | | | | | | | |--HandshakeCompleteDel.ExecuteIfBound()
| | | | | | | | | |--UPendingNetGame.SendInitialJoin() 
| | | | | | | | | | |--FNetControlMessage<NMT_Hello>::Send(ServerConn, IsLittleEndian, LocalNetworkVersion, EncryptionToken);
| | | | | | | | | | | |--UControlChannel.SendBunch()
| | | | | | | | | | | | |--UChannel.SendBunch()
| | | | | | | | | | | | | |--// 将bunch放入UChannel.SendBunch.OutgoingBunches中, 
| | | | | | | | | | | | | |--// 后续会清理UChannel.SendBunch.OutgoingBunches中的bunch
| | | | | | | | | | | | | |--OutgoingBunches.Add(Bunch);
| | | | | | | | | | | | | |--// This handles queuing reliable bunches into the ack list
| | | | | | | | | | | | | |--// UChannel.PrepBunch()
| | | | | | | | | | | | | |--FOutBunch *ThisOutBunch = PrepBunch(NextBunch, OutBunch, Merge); 
| | | | | | | | | | | | | | |--Bunch->Next = NULL;
| | | | | | | | | | | | | | |--Bunch->ChSequence = ++Connection->OutReliable[ChIndex];
| | | | | | | | | | | | | | |--UChannel.NumOutRec++;
| | | | | | | | | | | | | | |-- 将新bunch放入UChannel.OutRec链表的尾部
| | | | | | | | | | | | | | |-- Connection->LastOutBunch = OutBunch;
| | | | | | | | | | | | | |--UChannel.SendRawBunch()
| | | | | | | | | | | | | | |--OutBunch->ReceivedAck = 0;
| | | | | | | | | | | | | | |-- // UNetConnection.SendRawBunch()
| | | | | | | | | | | | | | |--int32 PacketId = Connection->SendRawBunch(*OutBunch, Merge, Collector);
| | | | | | | | | | | | | | | |--UNetDriver.OutBunches++
| | | | | | | | | | | | | | | |--UNetDriver.OutTotalBunches++
| | | | | | | | | | | | | | | |--UNetConnection.TimeSensitive = 1;
| | | | | | | | | | | | | | | |--//UNetConnection.SendBunchHeader是所有Bunch共用的Header内存,它是暂时的,用完即失效, 每次填充后立即与Bunch组合,一同放入SendBuffer中.
| | | | | | | | | | | | | | | |--填充SendBunchHeader
| | | | | | | | | | | | | | | |--填充SendBufferHeader(即,填充PacketHeader,见详解填充SendBufferHeader)
| | | | | | | | | | | | | | | |--UNetConnection.PrepareWriteBitsToSendBuffer()
| | | | | | | | | | | | | | | | |--//如果填充了PacketHeader则直接返回,否则执行如下填充流程
| | | | | | | | | | | | | | | | |--UNetConnection.WritePacketHeader()
| | | | | | | | | | | | | | | | | |--FNetPacketNotify.WriteHeader()
| | | | | | | | | | | | | | | | | | |--SequenceNumberT::SequenceT Seq = OutSeq.Get();
| | | | | | | | | | | | | | | | | | |--SequenceNumberT::SequenceT AckedSeq = InAckSeq.Get();
| | | | | | | | | | | | | | | | | | |--生成32bit的PackedHeader
| | | | | | | | | | | | | | | | | | |--uint32 PackedHeader = FPackedHeader::Pack(Seq, AckedSeq, WrittenHistoryWordCount - 1);
| | | | | | | | | | | | | | | | | | | |--uint32 Packed = 0u;
| | | | | | | | | | | | | | | | | | | |--Packed |= Seq.Get() << SeqShift;
| | | | | | | | | | | | | | | | | | | |--Packed |= AckedSeq.Get() << AckSeqShift;
| | | | | | | | | | | | | | | | | | | |--Packed |= HistoryWordCount & HistoryWordCountMask;
| | | | | | | | | | | | | | | | | | | |--return Packed;
| | | | | | | | | | | | | | | | | | |--Writer << PackedHeader; //将uint32序列化到sendbuffer中
| | | | | | | | | | | | | | | | | | |--InSeqHistory.Write(Writer, WrittenHistoryWordCount);
| | | | | | | | | | | | | | | | |--UNetConnection.WriteDummyPacketInfo()
| | | | | | | | | | | | | | | | | |--Writer.WriteBit(bHasPacketInfoPayload);
| | | | | | | | | | | | | | | | | |--// 如果payload有效
| | | | | | | | | | | | | | | | | |--Writer.SerializeBits(&DummyJitterClockTime, NetConnectionHelper::NumBitsForJitterClockTimeInHeader);
| | | | | | | | | | | | | | | | | |--Writer.WriteBit(bHasServerFrameTime);
| | | | | | | | | | | | | | | | | |--if (bHasServerFrameTime && Driver->IsServer())
| | | | | | | | | | | | | | | | | |--    Writer << DummyFrameTimeByte;
| | | | | | | | | | | | | | | | |--UNetConnection.WriteBitsToSendBufferInternal()
| | | | | | | | | | | | | | | | | |--SendBuffer填充bufferheader
| | | | | | | | | | | | | | | | | |--SendBuffer填充bunch
| | | | | | | | | | | | | | |--清理OutgoingBunches中的所有bunch.在这之后,bunch无效,不能再进行使用了.
| | | | | | | | | | |--ServerConn->FlushNet();
| | | | | | | | | | | |--Handler->OutgoingHigh(SendBuffer); //PacketHandler.OutgoingHigh()
| | | | | | | | | | | |--SendBuffer.WriteBit(1); //Write the UNetConnection-level termination bit 
| | | | | | | | | | | |--UNetConnection.WritePacketHeader()
| | | | | | | | | | | | |--FNetPacketNotify.WriteHeader()
| | | | | | | | | | | | | |--SequenceNumberT::SequenceT Seq = OutSeq.Get();
| | | | | | | | | | | | | |--SequenceNumberT::SequenceT AckedSeq = InAckSeq.Get();
| | | | | | | | | | | | | |--生成32bit的PackedHeader
| | | | | | | | | | | | | |--uint32 PackedHeader = FPackedHeader::Pack(Seq, AckedSeq, WrittenHistoryWordCount - 1);
| | | | | | | | | | | | | | |--uint32 Packed = 0u;
| | | | | | | | | | | | | | |--Packed |= Seq.Get() << SeqShift;
| | | | | | | | | | | | | | |--Packed |= AckedSeq.Get() << AckSeqShift;
| | | | | | | | | | | | | | |--Packed |= HistoryWordCount & HistoryWordCountMask;
| | | | | | | | | | | | | | |--return Packed;
| | | | | | | | | | | | | |--Writer << PackedHeader; //将uint32序列化到sendbuffer中
| | | | | | | | | | | | | |--InSeqHistory.Write(Writer, WrittenHistoryWordCount);
| | | | | | | | | | | |--UNetConnection.WriteFinalPacketInfo()
| | | | | | | | | | | | |--Writer.WriteBit(bHasPacketInfoPayload);
| | | | | | | | | | | | |--// 如果payload有效
| | | | | | | | | | | | |--Writer.SerializeBits(&DummyJitterClockTime, NetConnectionHelper::NumBitsForJitterClockTimeInHeader);
| | | | | | | | | | | | |--Writer.WriteBit(bHasServerFrameTime);
| | | | | | | | | | | | |--if (bHasServerFrameTime && Driver->IsServer())
| | | | | | | | | | | | |--    Writer << DummyFrameTimeByte;
| | | | | | | | | | | |--UNetConnection.LowLevelSend() // 真正发送数据包的地方


//DS处理ChallengeResponse,回复ChallengeAck
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UIpNetDriver.ProcessConnectionlessPacket()
| | |--PacketHandler.IncomingConnectionless()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.IncomingConnectionless()
| | | | | |--StatelessConnectHandlerComponent.ParseHandshakePacket()
| | | | | |--bChallengeSuccess = FMemory::Memcmp(Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0; // 服务器校验客户端发来的Cookie
| | | | | |--LastChallengeSuccessAddress = Address->Clone();
| | | | | |--int16* CurSequence = (int16*)Cookie;
| | | | | |--LastServerSequence = *CurSequence & (MAX_PACKETID - 1); // 初始化ServerSequenceID
| | | | | |--LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1); // 设置ClientSequenceID
| | | | | |--StatelessConnectHandlerComponent.SendChallengeAck()
| | |--StatelessConnect->HasPassedChallenge() //StatelessConnectHandlerComponent.HasPassedChallenge()
| | |--NewObject<UIpConnection>(); // 创建UIpConnection.
| | |--ReturnVal->InitRemoteConnection(..., USOCK_Open);// 初始化UIpConnection. UIpConnection::InitRemoteConnection()
| | | |--UIpConnection.InitBase()
| | | | |--UNetConnection.InitBase()
| | | | | |--UNetConnection.State=USOCK_Open. // 这里设置State为Open,等待客户端发来NMT_Hello时进行状态检测.
| | | | |--UNetConnection.InitSendBuffer() //初始化SendBuffer
| | | | |--UNetConnection.SetClientLoginState(EClientLoginState::LoggingIn) // 设置login状态为LoggingIn
| | | | |--UNetConnection.SetExpectedClientLoginMsgType(NMT_Hello) // 设置期望消息为:NMT_Hello
| | |--StatelessConnect->GetChallengeSequence(ServerSequence, ClientSequence);
| | |--ReturnVal->InitSequence(ClientSequence, ServerSequence);
| | | |--InPacketId = IncomingSequence - 1;
| | | |--OutPacketId = OutgoingSequence;
| | | |--OutAckPacketId = OutgoingSequence - 1;
| | | |--LastNotifiedPacketId = OutAckPacketId;
| | | |--InitInReliable = IncomingSequence & (MAX_CHSEQUENCE - 1);
| | | |--InitOutReliable = OutgoingSequence & (MAX_CHSEQUENCE - 1);
| | | |--InReliable.Init(InitInReliable, InReliable.Num());
| | | |--OutReliable.Init(InitOutReliable, OutReliable.Num());
| | | |--PacketNotify.Init(InPacketId, OutPacketId);
| | | | |--InSeqHistory.Reset();
| | | | |--InSeqHistory.Reset();
| | | | |--InSeq = InitialInSeq;
| | | | |--InAckSeq = InitialInSeq;
| | | | |--InAckSeqAck = InitialInSeq;
| | | | |--OutSeq = InitialOutSeq;
| | | | |--OutAckSeq = SequenceNumberT(InitialOutSeq.Get() - 1);
| | |--UNetDriver.AddClientConnection() //添加到ClientConnections中
| | | |--UNetDriver.CreateInitialServerChannels()
| | | | |--//DS在这里创建ServerChannel, 并且Channel的创建类型是EChannelCreateFlags::OpenedLocally
| | | | |--ClientConnection->CreateChannelByName(ChannelDef.ChannelName, EChannelCreateFlags::OpenedLocally, ChannelDef.StaticChannelIndex);
| | |--StatelessConnect->ResetChallengeData() //重置LastChallengeSuccessAddress等信息


// 详细分析收包堆栈
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--// 由于第一个bit为0,所以不是握手包,里面不会执行任何操作
| |--const ProcessedPacket UnProcessedPacket = Handler->Incoming(Data, Count);
| |--UNetConnection.ReceivedRawPacket()
| | |--PacketHandler.Incoming()
| | | |-- //当前还是以byte方式存储
| | | |--PacketView.DataView = {Packet, CountBytes, ECountUnits::Bytes};
| | | |--PacketView.Address = Address;
| | | |--PacketView.Traits.bConnectionlessPacket = bConnectionless; // 这里是false
| | | |--PacketHandler.Incoming_Internal()
| | | | |--计算该包的bit数量---剔除尾部所有为0的bit 
| | | | |--StatelessConnectHandlerComponent.Incoming()
| | | | | |--第一个bit为0, 非handshake包, 跳过所有握手逻辑.
| | | | |--// 讲过该函数处理后,发来的Packet包内未处理的bit会拷贝到PacketHandler.IncomingPacket中
| | | | |--PacketHandler.ReplaceIncomingPacket()
| | | | | |--//将Packet剩余未处理的bit拷贝到PacketHandler.IncomingPacket中, 注意当前只处理了第一个bit(用于判断是否为handshake)
| | | | | |--TempPacketData.AddUninitialized(ReplacementPacket.GetBytesLeft());
| | | | | |--TempPacketData[TempPacketData.Num()-1] = 0;
| | | | | |--int64 NewPacketSizeBits = ReplacementPacket.GetBitsLeft();
| | | | | |--ReplacementPacket.SerializeBits(TempPacketData.GetData(), NewPacketSizeBits);
| | | | | |--IncomingPacket.SetData(MoveTemp(TempPacketData), NewPacketSizeBits);
| | | | |--//将packet状态已由byte转换成bit了. 里面已经计算过有效bit为多少个
| | | | |--PacketView.DataView = {IncomingPacket.GetData(), (int32)IncomingPacket.GetBitsLeft(), ECountUnits::Bits};
| | |--//记录当前共收到了多少byte的packet
| | |--int32 PacketBytes = Count + PacketOverhead;
| | |--//去掉尾部的结束符(一个bit)
| | |--FBitReader Reader(Data, BitSize);
| | |--UNetConnection.ReceivedPacket()
| | | |--FNetPacketNotify.ReadHeader() // 处理消息头
| | | | |--// Read packed header
| | | | |--uint32 PackedHeader = 0;	
| | | | |--Reader << PackedHeader;
| | | | |--// unpack
| | | | |--Data.Seq = FPackedHeader::GetSeq(PackedHeader);
| | | | |--Data.AckedSeq = FPackedHeader::GetAckedSeq(PackedHeader);
| | | | |--Data.HistoryWordCount = FPackedHeader::GetHistoryWordCount(PackedHeader) + 1;
| | | | |--// Read ack history
| | | | |--Data.History.Read(Reader, Data.HistoryWordCount);
| | | |--// 获取InSeq之差, 之前已经收到Remote Seq和当前之差
| | | |--const int32 PacketSequenceDelta = PacketNotify.GetSequenceDelta(Header);
| | | |--如果PacketSequenceDelta>0, 该包有效, 不是以前收到过的Packet
| | | |--  const int32 MissingPacketCount = PacketSequenceDelta - 1;
| | | |--  CVarNetPacketOrderMaxMissingPackets.GetValueOnAnyThread() //默认最大丢包数量为3
| | | |--// Update incoming sequence data and deliver packet notifications
| | | |--// Packet is only accepted if both the incoming sequence number and incoming ack data are valid
| | | |--// 解析PacketHeader, 更新序列号相关成员变量
| | | |--PacketNotify.Update(Header, HandlePacketNotification);
| | | | |--const SequenceNumberT::DifferenceT InSeqDelta = GetSequenceDelta(NotificationData);
| | | | | |-- 如果合法,则返回SequenceNumberT::Diff(NotificationData.Seq, InSeq), 即旧InSeq和新packet的seq之差
| | | | |--FNetPacketNotify.ProcessReceivedAcks()
| | | | | |--if (NotificationData.AckedSeq > OutAckSeq) //如果Remote已经AckSeq比当前我们知道的(OutAckSeq)还大,则需要处理Remote相关Ack信息
| | | | | |--{
| | | | | |--  //计算当前Packet之中表明的Remote已经处理的Seq和本地保存的AckSeq之差
| | | | | |--  SequenceNumberT::DifferenceT AckCount = SequenceNumberT::Diff(NotificationData.AckedSeq, OutAckSeq);
| | | | | |--  InAckSeqAck = UpdateInAckSeqAck(AckCount, NotificationData.AckedSeq);
| | | | | | |-- 根据已经收到的RemoteAckSeq信息, 将已经记录在FNetPacketNotify.AckRecord中Remote已经处理的数据弹出
| | | | | | |-- AckRecord.PopNoCheck(AckCount - 1);
| | | | | | |-- // 并返回当前收到remote packet Seq对应的AckSeq信息
| | | | | | |-- return AckData.InAckSeq;
| | | | | |--  // 处理所有超范围ACK
| | | | | |--  UNetConnection.ReceivedPacket.else.HandlePacketNotification(CurrentAck, false)
| | | | | |--  // 处理在Packet.History.Storage中标记的AckSeq信息
| | | | | |--  UNetConnection.ReceivedPacket.else.HandlePacketNotification(CurrentAck, NotificationData.History.IsDelivered(AckCount))
| | | | | |--  // 把remote已经Ack的Seq(OutAckSeq)更新到最新
| | | | | |--  OutAckSeq = NotificationData.AckedSeq;
| | | | |--InSeq = NotificationData.Seq;
| | | |--// 循环解析Packet Body
| | | |--// 解析BunchHeader
| | | |--FInBunch Bunch( this );
| | | |--int32 IncomingStartPos		= Reader.GetPosBits();
| | | |--uint8 bControl				= Reader.ReadBit();
| | | |--Bunch.PacketId				= InPacketId;
| | | |--Bunch.bOpen					= bControl ? Reader.ReadBit() : 0;
| | | |--Bunch.bClose				= bControl ? Reader.ReadBit() : 0;
| | | |--Bunch.ChSequence = MakeRelative( Reader.ReadInt( MAX_CHSEQUENCE ), InReliable[Bunch.ChIndex], MAX_CHSEQUENCE );
| | | |--Bunch.bPartialInitial = Bunch.bPartial ? Reader.ReadBit() : 0;
| | | |--Bunch.bPartialFinal = Bunch.bPartial ? Reader.ReadBit() : 0;
| | | |--UPackageMap::StaticSerializeName(Reader, Bunch.ChName);
| | | |--int32 BunchDataBits  = Reader.ReadInt( UNetConnection::MaxPacket*8 );
| | | |--UChannel.ReceivedNextBunch 
| | | | |--UChannel.ReceivedNextBunch()
| | | | | |--UChannel.ReceivedSequencedBunch()
| | | | | | |--UControlChannel.ReceivedBunch() 
| | | | | | | |--// 序列化msgType
| | | | | | | |--Bunch << MessageType;
| | | | | | | |--这里会进行一些列特殊消息的特殊处理规则
| | | | | | | |--// UWorld.NotifyControlMessage() 
| | | | | | | |--Connection->Driver->Notify->NotifyControlMessage(Connection, MessageType, Bunch);
| | | | | | | | |--FNetControlMessage<NMT_Hello>::Receive(Bunch, IsLittleEndian, RemoteNetworkVersion, EncryptionToken)















// 通过UDP Socket发送数据
UNetConnection.FlushNet()
--// UIpConnection.LowLevelSend()
--LowLevelSend(SendBuffer.GetData(), SendBuffer.GetNumBits(), Traits);
|--LowLevelSend(SendBuffer.GetData(), SendBuffer.GetNumBits(), Traits);
| |--bWasSendSuccessful = Socket->SendTo(Packet.GetData(), Packet.Num(), Result.BytesSent, *RemoteAddr);




SequenceNumberT(InitialOutSeq.Get() - 1)
--ServerConn->FlushNet();
 |--Handler->OutgoingHigh(SendBuffer); //PacketHandler.OutgoingHigh()
 |--SendBuffer.WriteBit(1); //Write the UNetConnection-level termination bit 
 |--UNetConnection.WritePacketHeader()
 | |--FNetPacketNotify.WriteHeader()
 | | |--SequenceNumberT::SequenceT Seq = OutSeq.Get();
 | | |--SequenceNumberT::SequenceT AckedSeq = InAckSeq.Get();
 | | |--生成32bit的PackedHeader
 | | |--uint32 PackedHeader = FPackedHeader::Pack(Seq, AckedSeq, WrittenHistoryWordCount - 1);
 | | | |--uint32 Packed = 0u;
 | | | |--Packed |= Seq.Get() << SeqShift;
 | | | |--Packed |= AckedSeq.Get() << AckSeqShift;
 | | | |--Packed |= HistoryWordCount & HistoryWordCountMask;
 | | | |--return Packed;
 | | |--Writer << PackedHeader; //将uint32序列化到sendbuffer中
 | | |--InSeqHistory.Write(Writer, WrittenHistoryWordCount);
 |--UNetConnection.WriteFinalPacketInfo()
 | |--Writer.WriteBit(bHasPacketInfoPayload);
 | |--// 如果payload有效
 | |--Writer.SerializeBits(&DummyJitterClockTime, NetConnectionHelper::NumBitsForJitterClockTimeInHeader);
 | |--Writer.WriteBit(bHasServerFrameTime);
 | |--if (bHasServerFrameTime && Driver->IsServer())
 | |--    Writer << DummyFrameTimeByte;
 |--UNetConnection.LowLevelSend() // 真正发送数据包的地方
 |--PacketNotify.CommitAndIncrementOutSeq();
 | |--AckRecord.Enqueue( {OutSeq, WrittenInAckSeq} ); // 每次发送完成后,AckRecord记录OutSeq和WrittenInAckSeq
 | |--WrittenHistoryWordCount = 0u; // 每次发送Packet后,WrittenHistoryWordCount清零
 | |--++OutSeq // 每次发送完成后, OutSeq自增一
 
 
 
--UNetConnection.ReceivedPacket()
 |--PacketNotify.ReadHeader(Header, Reader)
 |--PacketNotify.Update(Header, HandlePacketNotification);
 | |--PacketNotify.Update(Header, HandlePacketNotification);
 | | |--FNetPacketNotify.ProcessReceivedAcks()
 | | | |--SequenceNumberT::DifferenceT AckCount = SequenceNumberT::Diff(NotificationData.AckedSeq, OutAckSeq);
 | | | |--InAckSeqAck = UpdateInAckSeqAck(AckCount, NotificationData.AckedSeq);
 | | | |--
 | | | |--
 | | |--InSeq = NotificationData.Seq;










DS发送ChallengeResponse, 设置等待消息NMT_Hello
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--UIpNetDriver.ProcessConnectionlessPacket()
| | |--PacketHandler.IncomingConnectionless()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.IncomingConnectionless()
| | | | | |--StatelessConnectHandlerComponent.ParseHandshakePacket()
| | | | | |--bChallengeSuccess = FMemory::Memcmp(Cookie, RegenCookie, COOKIE_BYTE_SIZE) == 0; // 服务器校验客户端发来的Cookie
| | | | | |--LastChallengeSuccessAddress = Address->Clone();
| | | | | |--int16* CurSequence = (int16*)Cookie;
| | | | | |--LastServerSequence = *CurSequence & (MAX_PACKETID - 1); // 初始化ServerSequenceID
| | | | | |--LastClientSequence = *(CurSequence + 1) & (MAX_PACKETID - 1); // 设置ClientSequenceID
| | | | | |--StatelessConnectHandlerComponent.SendChallengeAck()
| | |--StatelessConnect->HasPassedChallenge() //StatelessConnectHandlerComponent.HasPassedChallenge()
| | |--NewObject<UIpConnection>(); // 创建UIpConnection.
| | |--ReturnVal->InitRemoteConnection(..., USOCK_Open);// 初始化UIpConnection. UIpConnection::InitRemoteConnection()
| | | |--UIpConnection.InitBase()
| | | | |--UNetConnection.InitBase()
| | | | | |--UNetConnection.State=USOCK_Open. // 这里设置State为Open,等待客户端发来NMT_Hello时进行状态检测.
| | | | |--UNetConnection.InitSendBuffer() //初始化SendBuffer
| | | | |--UNetConnection.SetClientLoginState(EClientLoginState::LoggingIn) // 设置login状态为LoggingIn
| | | | |--UNetConnection.SetExpectedClientLoginMsgType(NMT_Hello) // 设置期望消息为:NMT_Hello
| | |--UNetDriver.AddClientConnection() //添加到ClientConnections中
| | |--StatelessConnect->ResetChallengeData() //重置LastChallengeSuccessAddress等信息



客户端收到ChallengeAck, 发送NMT_Hello
//UE4网络--详细分析FNetControlMessage<NMT_Hello>::Send
UWorld.Tick()
--UWorld.BroadcastTickDispatch()
|--UIpNetDriver.TickDispatch()
| |--FPacketIterator(UIpNetDriver* InDriver) //或者FPacketIterator::operator++()
| | |--FPacketIterator.FPacketIterator()
| | | |--FPacketIterator.AdvanceCurrentPacket()
| | | | |--FPacketIterator.ReceiveSinglePacket()
| | | | | |--Driver->GetSocket()->RecvFrom()
| |--UNetConnection.ReceivedRawPacket()
| | |--PacketHandler.Incoming_Internal()
| | | |--PacketHandler.Incoming_Internal()
| | | | |--StatelessConnectHandlerComponent.Incoming()
| | | | | |--HandlerComponent.Initialized()
| | | | | | |--PacketHandler.HandlerComponentInitialized()
| | | | | | | |--PacketHandler.HandlerInitialized()
| | | | | | | | |--// 详情查看:UE4网络---UPendingNetGame
| | | | | | | | |--HandshakeCompleteDel.ExecuteIfBound()
| | | | | | | | | |--UPendingNetGame.SendInitialJoin()
| | | | | | | | | | |--FNetControlMessage<NMT_Hello>::Send(ServerConn, IsLittleEndian, LocalNetworkVersion, EncryptionToken);


DS收到NMT_Hello, 发送NMT_Challenge
UWorld.Tick
--UIpNetDriver.TickDispatch()
|--UIpNetDriver.TickDispatch()
| |--UNetConnection.ReceivedRawPacket()
| | |--UNetConnection.ReceivedPacket()
| | | |--UChannel.ReceivedRawBunch()
| | | | |--UChannel.ReceivedNextBunch()
| | | | | |--UChannel.ReceivedSequencedBunch()
| | | | | | |--UControlChannel.ReceivedBunch()
| | | | | | | |--UWorld.NotifyControlMessage()
| | | | | | | | |--// 检测版本号,加密数据, 如果合法就直接发送NMT_Login
| | | | | | | | |--Challenge = FString::Printf(TEXT("%08X"), FPlatformTime::Cycles());
| | | | | | | | |--SetExpectedClientLoginMsgType(NMT_Login);
| | | | | | | | |--FNetControlMessage<NMT_Challenge>::Send(this, Challenge);




客户端收到NMT_Challenge, 发送NMT_Login
UGameEngine.Tick()
--UEngine.TickWorldTravel()
 |--UPendingNetGame.Tick()
 | |--UIpNetDriver.TickDispatch()
 | | |--UNetConnection.ReceivedRawPacket()
 | | | |--UNetConnection.ReceivedPacket()
 | | | | |--UChannel.ReceivedRawBunch()
 | | | | | |--UChannel.ReceivedNextBunch()
 | | | | | | |--UChannel.ReceivedSequencedBunch()
 | | | | | | | |--UControlChannel.ReceivedBunch() 
 | | | | | | | | |--UPendingNetGame.NotifyControlMessage()
 | | | | | | | | | |--//解析NMT_Challenge, 并将DS的Challenge填充到UNetConnection.Challenge中
 | | | | | | | | | |--FNetControlMessage<NMT_Challenge>::Receive(Bunch, Connection->Challenge)
 | | | | | | | | | |-- // 填充nickname
 | | | | | | | | | |--FString OverrideName = LocalPlayer->GetNickname();
 | | | | | | | | | |--PartialURL.AddOption(*FString::Printf(TEXT("Name=%s"), *OverrideName));
 | | | | | | | | | |-- // 填充GameUrlOptions信息
 | | | | | | | | | |--FString GameUrlOptions = LocalPlayer->GetGameLoginOptions();
 | | | | | | | | | |--PartialURL.AddOption(*FString::Printf(TEXT("%s"), *GameUrlOptions));
 | | | | | | | | | |--//填充PlayerID
 | | | | | | | | | |--Connection->PlayerId = LocalPlayer->GetPreferredUniqueNetId();
 | | | | | | | | | |--//设置OnlinePlatformName
 | | | | | | | | | |--OnlinePlatformName = WorldContext->OwningGameInstance->GetOnlinePlatformName();
 | | | | | | | | | |--//设置ClientResponse
 | | | | | | | | | |--Connection->ClientResponse = TEXT("0");
 | | | | | | | | | |--// 发送NMT_Login
 | | | | | | | | | |--FNetControlMessage<NMT_Login>::Send(Connection, Connection->ClientResponse, URLString, Connection->PlayerId, OnlinePlatformNameString);


DS收到NMT_Login,发送NMT_Welcome
UWorld.Tick
--UIpNetDriver.TickDispatch()
 |--UIpNetDriver.TickDispatch()
 | |--UNetConnection.ReceivedRawPacket()
 | | |--UNetConnection.ReceivedPacket()
 | | | |--UChannel.ReceivedRawBunch()
 | | | | |--UChannel.ReceivedNextBunch()
 | | | | | |--UChannel.ReceivedSequencedBunch()
 | | | | | | |--UControlChannel.ReceivedBunch()
 | | | | | | | |--UWorld.NotifyControlMessage()
 | | | | | | | | |--//根据客户端信息填充UNetConnection.ClientResponse
 | | | | | | | | |--FNetControlMessage<NMT_Login>::Receive(Bunch, Connection->ClientResponse, RequestURL, UniqueIdRepl,OnlinePlatformName);
 | | | | | | | | |-- //根据客户端信息填充UNetConnection.PlayerId 
 | | | | | | | | |--Connection->PlayerId = UniqueIdRepl;
 | | | | | | | | |--// 根据客户端信息填充UNetConnection.PlayerOnlinePlatformName 
 | | | | | | | | |--Connection->SetPlayerOnlinePlatformName(FName(*OnlinePlatformName));
 | | | | | | | | |--GameMode->PreLogin(Tmp, Connection->LowLevelGetRemoteAddress(), Connection->PlayerId, ErrorMsg);
 | | | | | | | | |--UWorld.WelcomePlayer()
 | | | | | | | | | |--Connection->SetClientWorldPackageName(CurrentLevel->GetOutermost()->GetFName());
 | | | | | | | | | | |--UNetConnection.ClientWorldPackageName = NewClientWorldPackageName
 | | | | | | | | | | |--UNetConnection.UpdateAllCachedLevelVisibility()
 | | | | | | | | | |--GameName = AuthorityGameMode->GetClass()->GetPathName();
 | | | | | | | | | |--AuthorityGameMode->GameWelcomePlayer(Connection, RedirectURL);// 空函数,具体项目会重写
 | | | | | | | | | |--FNetControlMessage<NMT_Welcome>::Send(Connection, LevelName, GameName, RedirectURL);
 | | | | | | | | | |--Connection->FlushNet();
 | | | | | | | | | |--Connection->QueuedBits = 0;
 | | | | | | | | | |--Connection->SetClientLoginState( EClientLoginState::Welcomed );	
 | | | | | | | | | | |--UNetConnection.ClientLoginState = EClientLoginState::Welcomed




客户端收到NMT_Welcome,发送NMT_Netspeed.
UGameEngine.Tick()
--UEngine.TickWorldTravel()
 |--UPendingNetGame.Tick()
 | |--UIpNetDriver.TickDispatch()
 | | |--UNetConnection.ReceivedRawPacket()
 | | | |--UNetConnection.ReceivedPacket()
 | | | | |--UChannel.ReceivedRawBunch()
 | | | | | |--UChannel.ReceivedNextBunch()
 | | | | | | |--UChannel.ReceivedSequencedBunch()
 | | | | | | | |--UControlChannel.ReceivedBunch() 
 | | | | | | | | |--UPendingNetGame.NotifyControlMessage()
 | | | | | | | | | |--//解析NMT_Welcome, GameName:/Game/GamePlay/NewGameMode.NewGameMode_C, 
 | | | | | | | | | |--//URL.Map:/Game/ThirdPersonCPP/Maps/ThirdPersonExampleMap
 | | | | | | | | | |--//RedirectURL:空
 | | | | | | | | | |--FNetControlMessage<NMT_Welcome>::Receive(Bunch, URL.Map, GameName, RedirectURL)
 | | | | | | | | | |-- // 将GameMode填充到URL.op中. 即game=/Game/GamePlay/NewGameMode.NewGameMode_C
 | | | | | | | | | |--URL.AddOption(*FString::Printf(TEXT("game=%s"), *GameName));
 | | | | | | | | | |--//发送NMT_Netspeed
 | | | | | | | | | |--FNetControlMessage<NMT_Netspeed>::Send(Connection, Connection->CurrentNetSpeed);
 | | | | | | | | | |-- // 根据UPendingNetGame.bSuccessfullyConnected变量,在下一帧tick时候, 会加载地图
 | | | | | | | | | |-- UPendingNetGame.bSuccessfullyConnected = true;
 |-- // 检测Context.PendingNetGame->bSuccessfullyConnected是否OK
 |-- 检测: Context.PendingNetGame && Context.PendingNetGame->bSuccessfullyConnected && !Context.PendingNetGame->bSentJoinRequest 
 |--      && (Context.OwningGameInstance == NULL || !Context.OwningGameInstance->DelayPendingNetGameTravel()))
 |--UEngine.MakeSureMapNameIsValid()
 |--//客户端切换地图
 |--const bool bLoadedMapSuccessfully = LoadMap(Context, Context.PendingNetGame->URL, Context.PendingNetGame, Error);
 | |--FLoadTimeTracker::Get().ResetRawLoadTimes();
 | |--WorldContext.World()->bIsLevelStreamingFrozen = false;
 | |--//广播PreLoadMap事件
 | |--FCoreUObjectDelegates::PreLoadMap.Broadcast(URL.Map);
 | |--FlushAsyncLoading();
 | |--CancelPendingMapChange(WorldContext);
 | | |--Context.LevelsToLoadForPendingMapChange.Empty();
 | | |--Context.LoadedLevelsForPendingMapChange.Empty();
 | | |--Context.PendingMapChangeFailureDescription	= TEXT("");
 | | |--Context.bShouldCommitPendingMapChange		= false;
 | | |--Context.World()->PreparingLevelNames.Empty();
 | |--WorldContext.SeamlessTravelHandler.CancelTravel();
 | |--WorldContext.World()->BeginTearingDown();
 | | |--bIsTearingDown = true;
 | | |--BeginTearingDownEvent.Broadcast();
 | | |--FWorldDelegates::OnWorldBeginTearDown.Broadcast(this);
 | |--UEngine.LoadMapRedrawViewports()
 | | |--UGameEngine.RedrawViewports()
 | | | |--GameViewport->Viewport->Draw(bShouldPresent);
 | |--TransitionType = ETransitionType::None;
 | |--ShutdownWorldNetDriver(WorldContext.World());
 | | |--World->SetNetDriver(NULL);
 | | |--DestroyNamedNetDriver(World, NetDriver->NetDriverName);
 | | | |--DestroyNamedNetDriver_Local( GetWorldContextFromWorldChecked(InWorld), NetDriverName);
 | | | |--//销毁指定名字(NetDriverName)的UNetDriver
 | | | |--NetDriver->SetWorld(NULL);
 | | | |--NetDriver->Shutdown();
 | | | |--NetDriver->LowLevelDestroy();
 | | | |--Context.ActiveNetDrivers.RemoveAtSwap(Index);
 | | | |--Context.World()->ClearNetDriver(NetDriver);
 | |--WorldContext.World()->FlushLevelStreaming(EFlushLevelStreamingType::Visibility);
 | |--FWorldDelegates::LevelRemovedFromWorld.Broadcast(nullptr, WorldContext.World());
 | |--//for all LocalPlayer
 | |--// Destroy all playercontroller and its owned pawn
 | |--// Disassociate the players from their PlayerControllers in this world.
 | |--if (WorldContext.OwningGameInstance != nullptr)
 | |--{
 | |--	for(auto It = WorldContext.OwningGameInstance->GetLocalPlayerIterator(); It; ++It)
 | |--	{
 | |--		ULocalPlayer *Player = *It;
 | |--		if(Player->PlayerController && Player->PlayerController->GetWorld() == WorldContext.World())
 | |--		{
 | |--			if(Player->PlayerController->GetPawn())
 | |--			{
 | |--				WorldContext.World()->DestroyActor(Player->PlayerController->GetPawn(), true);
 | |--			}
 | |--			WorldContext.World()->DestroyActor(Player->PlayerController, true);
 | |--			Player->PlayerController = nullptr;
 | |--		}
 | |--		// reset split join info so we'll send one after loading the new map if necessary
 | |--		Player->bSentSplitJoin = false;
 | |--		// When loading maps, clear out mids that are referenced as they may prevent the world from shutting down cleanly and the local player will not be cleaned up until later
 | |--		Player->CleanupViewState(); 
 | |--	}
 | |--}
 | |--// route EndPlay all world actors
 | |--for (FActorIterator ActorIt(WorldContext.World()); ActorIt; ++ActorIt)
 | |--{
 | |--	ActorIt->RouteEndPlay(EEndPlayReason::LevelTransition);
 | |--}
 | |--WorldContext.World()->CleanupWorld();
 | | |--UWorld.CleanupWorldGlobalTag++;
 | | |--UWorld.CleanupWorldInternal(bSessionEnded, bCleanupResources, NewWorld);
 | | | |--CleanupWorldTag = CleanupWorldGlobalTag;
 | | | |--FWorldDelegates::OnWorldCleanup.Broadcast(this, bSessionEnded, bCleanupResources);
 | | | |--GetRendererModule().OnWorldCleanup(this, bSessionEnded, bCleanupResources, bWorldChanged);
 | | | |--// cleanup net driver
 | | | |--ForEachNetDriver(GEngine, this, [](UNetDriver* const Driver)
 | | | |--{
 | | | |--	if (Driver != nullptr)
 | | | |--	{
 | | | |--		Driver->GetNetworkObjectList().Reset();
 | | | |--	}
 | | | |--});
 | | | |--UWorld.ClearWorldComponents()
 | | | | |--for( int32 LevelIndex=0; LevelIndex<Levels.Num(); LevelIndex++ )
 | | | | |--{
 | | | | |--	ULevel* Level = Levels[LevelIndex];
 | | | | |--	Level->ClearLevelComponents();
 | | | | | |--bAreComponentsCurrentlyRegistered = false;
 | | | | | |--
 | | | | | |--// Remove the model components from the scene.
 | | | | | |--for (UModelComponent* ModelComponent : ModelComponents)
 | | | | | |--{
 | | | | | |--	if (ModelComponent && ModelComponent->IsRegistered())
 | | | | | |--	{
 | | | | | |--		ModelComponent->UnregisterComponent();
 | | | | | |--	}
 | | | | | |--}
 | | | | | |--
 | | | | | |--// Remove the actors' components from the scene and build a list of relevant worlds
 | | | | | |--// In theory (though it is a terrible idea), users could spawn Actors from an OnUnregister event so don't use ranged-for
 | | | | | |--for (int32 ActorIndex = 0; ActorIndex < Actors.Num(); ++ActorIndex)
 | | | | | |--{
 | | | | | |--	AActor* Actor = Actors[ActorIndex];
 | | | | | |--	if (Actor)
 | | | | | |--	{
 | | | | | |--		Actor->UnregisterAllComponents();
 | | | | | |--	}
 | | | | | |--}
 | | | | |--}
 | | | | |--
 | | | | |--if(LineBatcher && LineBatcher->IsRegistered())
 | | | | |--{
 | | | | |--	LineBatcher->UnregisterComponent();
 | | | | |--}
 | | | | |--
 | | | | |--if(PersistentLineBatcher && PersistentLineBatcher->IsRegistered())
 | | | | |--{
 | | | | |--	PersistentLineBatcher->UnregisterComponent();
 | | | | |--}
 | | | | |--
 | | | | |--if(ForegroundLineBatcher && ForegroundLineBatcher->IsRegistered())
 | | | | |--{
 | | | | |--	ForegroundLineBatcher->UnregisterComponent();
 | | | | |--}
 | | | | |--
 | | | | |--if (PhysicsField && PhysicsField->IsRegistered())
 | | | | |--{
 | | | | |--	PhysicsField->UnregisterComponent();
 | | | | |--}
 | | | |--PersistentLevel->ReleaseRenderingResources();
 | | | |--// for all level, cleanup it owner world
 | | | |--for (int32 LevelIndex = 0; LevelIndex < GetNumLevels(); ++LevelIndex)
 | | | |--{
 | | | |--	UWorld* World = CastChecked<UWorld>(GetLevel(LevelIndex)->GetOuter());
 | | | |--	World->CleanupWorldInternal(bSessionEnded, bCleanupResources, NewWorld);
 | | | |--}
 | | | |--// for streaming level, cleanup it owner world
 | | | |--for (ULevelStreaming* StreamingLevel : GetStreamingLevels())
 | | | |--{
 | | | |--	if (ULevel* Level = StreamingLevel->GetLoadedLevel())
 | | | |--	{
 | | | |--		UWorld* World = CastChecked<UWorld>(Level->GetOuter());
 | | | |--		World->CleanupWorldInternal(bSessionEnded, bCleanupResources, NewWorld);
 | | | |--	}
 | | | |--}
 | | | |--// for dynamic duplicate levels
 | | | |--UWorld* const LevelWorld = CastChecked<UWorld>(Level->GetOuter());
 | | | |--LevelWorld->CleanupWorldInternal(bSessionEnded, bCleanupResources, NewWorld);
 | | | |--FWorldDelegates::OnPostWorldCleanup.Broadcast(this, bSessionEnded, bCleanupResources);
 | |--GEngine->WorldDestroyed(WorldContext.World());
 | |--WorldContext.World()->RemoveFromRoot();
 | |--WorldContext.SetCurrentWorld(nullptr);
 | |--//在还没有加载地图之前, 做一些预加载工作
 | |--WorldContext.OwningGameInstance->PreloadContentForURL(URL);
 | |--UWorld::WorldTypePreLoadMap.FindOrAdd( URLMapFName ) = WorldContext.WorldType;
 | |--WorldPackage = FindPackage(nullptr, *URL.Map);
 | |--// if not load the map, load it.
 | |--WorldPackage = LoadPackage(nullptr, *URL.Map, (WorldContext.WorldType == EWorldType::PIE ? LOAD_PackageForPIE : LOAD_None));
 | |--UWorld::WorldTypePreLoadMap.Remove( URLMapFName );
 | |--NewWorld = UWorld::FindWorldInPackage(WorldPackage);
 | |--// handle the MapBuildData
 | |--NewWorld->PersistentLevel->HandleLegacyMapBuildData();
 | |--// set GameInstance for the new world.
 | |--NewWorld->SetGameInstance(WorldContext.OwningGameInstance);
 | |--// set global world
 | |--GWorld = NewWorld;
 | |--WorldContext.SetCurrentWorld(NewWorld);
 | |--WorldContext.World()->WorldType = WorldContext.WorldType;
 | |--WorldContext.World()->AddToRoot();
 | |--WorldContext.World()->InitWorld();
 | | |--InitializeSubsystems(); // intit world subsystem
 | | | |--SubsystemCollection.Initialize(this);
 | | |--FWorldDelegates::OnPreWorldInitialization.Broadcast(this, IVS);
 | | |--CreateAISystem();
 | | |--if (PersistentLevel->GetOuter() != this)
 | | |--{
 | | |--	// Move persistent level into world so the world object won't get garbage collected in the multi- level
 | | |--	// case as it is still referenced via the level's outer. This is required for multi- level editing to work.
 | | |--	PersistentLevel->Rename( *PersistentLevel->GetName(), this, REN_ForceNoResetLoaders );
 | | |--}
 | | |--PersistentLevel->OwningWorld = this;
 | | |--PersistentLevel->bIsVisible = true;
 | | |--IStreamingManager::Get().AddLevel(PersistentLevel);
 | | |--BroadcastLevelsChanged();
 | |--MovePendingLevel(WorldContext);
 | | |--Context.World()->SetNetDriver(Context.PendingNetGame->NetDriver);
 | | | |--UWorld.NetDriver = NewDriver;
 | | |--NetDriver->SetNetDriverName(NAME_GameNetDriver);
 | | |--NetDriver->SetWorld(Context.World());
 | | |--
 | | |--FLevelCollection& SourceLevels = Context.World()->FindOrAddCollectionByType(ELevelCollectionType::DynamicSourceLevels);
 | | |--SourceLevels.SetNetDriver(NetDriver);
 | | |--
 | | |--FLevelCollection& StaticLevels = Context.World()->FindOrAddCollectionByType(ELevelCollectionType::StaticLevels);
 | | |--StaticLevels.SetNetDriver(NetDriver);
 | | |--// clean navigation system
 | | |--Context.World()->SetNavigationSystem(nullptr);
 | |--WorldContext.World()->SetGameMode(URL);
 | | |--// do nothing on the client
 | |--WorldContext.World()->FlushLevelStreaming(EFlushLevelStreamingType::Visibility);
 | |--WorldContext.World()->CreateAISystem();
 | |--WorldContext.World()->InitializeActorsForPlay(URL, true, &Context);
 | | |--UWorld.UpdateCullDistanceVolumes()
 | |--FNavigationSystem::AddNavigationSystemToWorld(*WorldContext.World(), FNavigationSystemRunMode::GameMode);
 | | |--NavigationSystemConfig = WorldSettings->GetNavigationSystemConfig();
 | | |--NavigationSystemConfig->CreateAndConfigureNavigationSystem(WorldOwner)
 | | |--WorldOwner.SetNavigationSystem(NavSysInstance);	
 | | |--WorldOwner.GetNavigationSystem()->InitializeForWorld(WorldOwner, ResolvedRunMode);
 | |--// for client
 | |--WorldContext.LastRemoteURL = URL;
 | |--// spawn player controller for local player
 | |--!(*It)->SpawnPlayActor(URL.ToString(1),Error2,WorldContext.World())
 | | |--PlayerController = InWorld->SpawnActor<APlayerController>(PCClass, SpawnInfo);
 | | |--const int32 PlayerIndex = GEngine->GetGamePlayers(InWorld).Find(this);
 | | |--PlayerController->NetPlayerIndex = PlayerIndex;
 | | |--PlayerController->Player = this;
 | |--IStreamingManager::Get().NotifyLevelChange();
 | |--GEngine->XRSystem->OnBeginPlay(WorldContext);
 | |--WorldContext.World()->BeginPlay();
 | | |--// for client brocast OnWorldBeginPlay
 | | |--OnWorldBeginPlay.Broadcast();
 | |--PostLoadMapCaller.Broadcast(WorldContext.World());
 | |--WorldContext.World()->bWorldWasLoadedThisTick = true;
 | |--RedrawViewports(false);
 | |--// tell gameinstance, the map load complete with load time
 | |--WorldContext.OwningGameInstance->LoadComplete(StopTime - StartTime, *URL.Map);
 |--Context.PendingNetGame->LoadMapCompleted(this, Context, bLoadedMapSuccessfully, Error);
 | |--Engine->TransitionType = ETransitionType::Connecting;
 | |--Engine->RedrawViewports(false);
 | |--Context.PendingNetGame->SendJoin();
 | | |--bSentJoinRequest = true;
 | | |--FNetControlMessage<NMT_Join>::Send(NetDriver->ServerConnection);
 | | |--NetDriver->ServerConnection->FlushNet(true);
 | |--Context.PendingNetGame->NetDriver = NULL;
 |--Context.PendingNetGame = nullptr;

 
Connection->SetClientLoginState(EClientLoginState::ReceivedJoin);

DS收到NMT_Join, 
UGameEngine.Tick()
--UEngine.TickWorldTravel()
 |--UPendingNetGame.Tick()
 | |--UIpNetDriver.TickDispatch()
 | | |--UNetConnection.ReceivedRawPacket()
 | | | |--UNetConnection.ReceivedPacket()
 | | | | |--UChannel.ReceivedRawBunch()
 | | | | | |--UChannel.ReceivedNextBunch()
 | | | | | | |--UChannel.ReceivedSequencedBunch()
 | | | | | | | |--UControlChannel.ReceivedBunch() 
 | | | | | | | | |--UWorld.NotifyControlMessage()
 | | | | | | | | | |--Connection->PlayerController = SpawnPlayActor( Connection, ROLE_AutonomousProxy, InURL, Connection->PlayerId, ErrorMsg );
 | | | | | | | | | | |--UWorld.SpawnPlayActor(NewPlayer, RemoteRole, InURL, UniqueIdRepl, Error, InNetPlayerIndex);
 | | | | | | | | | | | |--APlayerController* const NewPlayerController = GameMode->Login(NewPlayer, RemoteRole, *InURL.Portal, Options, UniqueId, Error);
 | | | | | | | | | | | | |--ErrorMessage = GameSession->ApproveLogin(Options);
 | | | | | | | | | | | | |--APlayerController* const NewPlayerController = SpawnPlayerController(InRemoteRole, Options);
 | | | | | | | | | | | | | |--AGameModeBase.SpawnPlayerController()
 | | | | | | | | | | | | | | |--AGameModeBase.SpawnPlayerControllerCommon()
 | | | | | | | | | | | | | | | |--APlayerController* NewPC = GetWorld()->SpawnActor<APlayerController>(InPlayerControllerClass, SpawnLocation, SpawnRotation, SpawnInfo);
 | | | | | | | | | | | | | | | |--UGameplayStatics::FinishSpawningActor(NewPC, FTransform(SpawnRotation, SpawnLocation));
 | | | | | | | | | | | | |--AGameModeBase.InitNewPlayer(NewPlayerController, UniqueId, Options, Portal);
 | | | | | | | | | | | | | |--GameSession->RegisterPlayer(NewPlayerController, UniqueId.GetUniqueNetId(), UGameplayStatics::HasOption(Options, TEXT("bIsFromInvite")));
 | | | | | | | | | | | | | |--AActor* const StartSpot = FindPlayerStart(NewPlayerController, Portal);
 | | | | | | | | | | | | | |--AGameModeBase.ChangeName()
 | | | | | | | | | | | | | | |--Other->PlayerState->SetPlayerName(S);
 | | | | | | | | | | | | | | | |--APlayerState.SetPlayerNameInternal(S);
 | | | | | | | | | | | | | | | | |--PlayerNamePrivate = S
 | | | | | | | | | | | | | | | |--OldNamePrivate = GetPlayerName();
 | | | | | | | | | | | | | | |--K2_OnChangeName(Other, S, bNameChange);
 | | | | | | | | | | | |--NewPlayerController->NetPlayerIndex = InNetPlayerIndex;
 | | | | | | | | | | | |--NewPlayerController->SetRole(ROLE_Authority);
 | | | | | | | | | | | |--NewPlayerController->SetReplicates(RemoteRole != ROLE_None);
 | | | | | | | | | | | |--NewPlayerController->SetAutonomousProxy(true);
 | | | | | | | | | | | |--NewPlayerController->SetPlayer(NewPlayer);
 | | | | | | | | | | | | |--APlayerController.Player = InPlayer;
 | | | | | | | | | | | | |--InPlayer->PlayerController = this;
 | | | | | | | | | | | | |--NetConnection = Cast<UNetConnection>(InPlayer);
 | | | | | | | | | | | | |--NetConnection->OwningActor = this;
 | | | | | | | | | | | | |--APlayerController.UpdateStateInputComponents();
 | | | | | | | | | | | | |--APlayerController.ReceivedPlayer()
 | | | | | | | | | | | |--GameMode->PostLogin(NewPlayerController);
 | | | | | | | | | | | | |--AGameModeBase.GenericPlayerInitialization(NewPlayer)
 | | | | | | | | | | | | | |--AGameModeBase.InitializeHUDForPlayer(PC);
 | | | | | | | | | | | | | | |--NewPlayer->ClientSetHUD(HUDClass); // 通知client,创建HUD
 | | | | | | | | | | | | | | | |--MyHUD = GetWorld()->SpawnActor<AHUD>(NewHUDClass, SpawnInfo );
 | | | | | | | | | | | | | |--AGameModeBase.UpdateGameplayMuteList(PC);
 | | | | | | | | | | | | | |--PC->ClientEnableNetworkVoice(!GameSession->RequiresPushToTalk());
 | | | | | | | | | | | | | |--AGameModeBase.ReplicateStreamingStatus(PC) // 更新Streaminglevel状态
 | | | | | | | | | | | | | |--PC->SetCinematicMode(true, HidePlayer, HideHUD, DisableMovement, DisableTurning);
 | | | | | | | | | | | | | |--GameSession->PostLogin(NewPlayer);
 | | | | | | | | | | | | | |--FGameModeEvents::GameModePostLoginEvent.Broadcast(this, NewPlayer);
 | | | | | | | | | | | | | |--HandleStartingNewPlayer(NewPlayer);
 | | | | | | | | | | | | | | |--AGameModeBase.RestartPlayer(NewPlayer);
 | | | | | | | | | | | | | | | |--AActor* StartSpot = FindPlayerStart(NewPlayer);
 | | | | | | | | | | | | | | | |--RestartPlayerAtPlayerStart(NewPlayer, StartSpot);
 | | | | | | | | | | | | | | | | |--NewPlayer->SetPawn(SpawnDefaultPawnFor(NewPlayer, StartSpot));
 | | | | | | | | | | | | | | | | |--InitStartSpot(StartSpot, NewPlayer);
 | | | | | | | | | | | | | | | | |--FinishRestartPlayer(NewPlayer, SpawnRotation);
 | | | | | | | | | | | | | | | | | |--NewPlayer->Possess(NewPlayer->GetPawn());
 | | | | | | | | | | | | | | | | | |--NewPlayer->ClientSetRotation(NewPlayer->GetPawn()->GetActorRotation(), true);
 | | | | | | | | | | | | | | | | | |--NewPlayer->SetControlRotation(NewControllerRot);
 | | | | | | | | | | | | | | | | | |--SetPlayerDefaults(NewPlayer->GetPawn());
 | | | | | | | | | | | | | | | | | |--K2_OnRestartPlayer(NewPlayer);
 | | | | | | | | | |--Connection->SetClientLoginState(EClientLoginState::ReceivedJoin);



--
 |--
 | |--
 | | |--
 | | | |--
 | | | | |--
 | | | | | |--
 | | | | | | |--
 | | | | | | | |--
 | | | | | | | | |--
 | | | | | | | | | |--
 | | | | | | | | | | |--
 | | | | | | | | | | | |--
 | | | | | | | | | | | | |--
 | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | | | |--
 

每个需要属性同步的Actor在创建的时候, 都需要注册到UNetDriver.NetworkObjects中
UWorld.SpawnActor()
--UWorld.AddNetworkActor()
 |--ForEachNetDriver()
 | |--UNetDriver.AddNetworkActor()
 | | |--GetNetworkObjectList().FindOrAdd(Actor, this); //FNetworkObjectList::FindOrAdd
 | | | |--FNetworkObjectList.ActiveNetworkObjects.Add(*NetworkObjectInfo);




发送RPC时候, 如果Actor没有对应的Channel,需要先创建, 再使用.
UWorld.Tick()
--UIpNetDriver.TickDispatch()
 |--UNetConnection.ReceivedRawPacket()
 | |--UNetConnection.ReceivedPacket()
 | | |--UChannel.ReceivedRawBunch()
 | | | |--UChannel.ReceivedNextBunch()
 | | | | |--UChannel.ReceivedSequencedBunch()
 | | | | | |--UControlChannel.ReceivedBunch()
 | | | | | | |--UWorld.NotifyControlMessage()
 | | | | | | | |--UWorld.SpawnPlayActor()
 | | | | | | | | |--AGameModeBase.PostLogin()
 | | | | | | | | | |--AGameModeBase.GenericPlayerInitialization()
 | | | | | | | | | | |--AGameModeBase.InitializeHUDForPlayer()
 | | | | | | | | | | | |--APlayerController.ClientSetHUD()
 | | | | | | | | | | | | |--AActor.ProcessEvent()
 | | | | | | | | | | | | | |--UObject.ProcessEvent()
 | | | | | | | | | | | | | | |--AActor.CallRemoteFunction()
 | | | | | | | | | | | | | | | |--UNetDriver.ProcessRemoteFunction()
 | | | | | | | | | | | | | | | | |--UNetDriver.InternalProcessRemoteFunction()
 | | | | | | | | | | | | | | | | | |--UNetDriver.InternalProcessRemoteFunctionPrivate()
 | | | | | | | | | | | | | | | | | | |--UActorChannel.SetChannelActor()
 | | | | | | | | | | | | | | | | | | | |--UActorChannel.FindOrCreateReplicator()
 | | | | | | | | | | | | | | | | | | | | |--UNetConnection.CreateReplicatorForNewActorChannel()
 | | | | | | | | | | | | | | | | | | | | | |--FObjectReplicator.InitWithObject()
 | | | | | | | | | | | | | | | | | | | | | | |--UNetDriver.GetObjectClassRepLayout()
 | | | | | | | | | | | | | | | | | | | | | | | |--FRepLayout.CreateFromClass()
 | | | | | | | | | | | | | | | | | | | | | | | | |--FRepLayout.InitFromClass()
 | | | | | | | | | | | | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | | | | | | | | | | | | | | |--




收集Class中需要网络复制的变量和函数
UNetDriver.TickFlush()
--UNetDriver.ServerReplicateActors()
 |--UNetDriver.ServerReplicateActors_ProcessPrioritizedActors()
 | |--UActorChannel.ReplicateActor()
 | | |--FObjectReplicator.ReplicateProperties()
 | | | |--FRepLayout.ReplicateProperties()
 | | | | |--FRepLayout.SendProperties()
 | | | | | |--FRepLayout.SendProperties_r()
 | | | | | | |--FObjectPropertyBase.NetSerializeItem()
 | | | | | | | |--UPackageMapClient.SerializeObject()
 | | | | | | | | |--FNetGUIDCache.GetOrAssignNetGUID()
 | | | | | | | | | |--FNetGUIDCache.AssignNewNetGUID_Server()
 | | | | | | | | | | |--FNetGUIDCache.RegisterNetGUID_Server()
 | | | | | | | | | | | |--FNetGUIDCache.GetNetworkChecksum()
 | | | | | | | | | | | | |--FClassNetCacheMgr.GetClassNetCache()
 | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | | |--
 | | | | | | | | | | | | | | | | | |--





// 在第一次调用RPC函数时, 如果没有创建对应的Replicator, 会触发Replicator的创建流程
//创建流程如下
--APlayerController::ClientSetHUD()
 |--AActor.ProcessEvent()
 | |--UObject.ProcessEvent()
 | | |--AActor.CallRemoteFunction()
 | | | |--UNetDriver.ProcessRemoteFunction()
 | | | | |--UNetDriver.InternalProcessRemoteFunction()
 | | | | | |--UNetDriver.InternalProcessRemoteFunctionPrivate()
 | | | | | | |--UActorChannel.SetChannelActor()
 | | | | | | | |--UActorChannel.FindOrCreateReplicator()
 | | | | | | | | |--FObjectReplicator.StartReplicating()
 | | | | | | | | | |--FObjectReplicator.OwningChannel = InActorChannel; // 设置FObjectReplicator对应的channel
 | | | | | | | | | |--FObjectReplicator.ObjectNetGUID = ConnectionNetDriver->GuidCache->GetOrAssignNetGUID( Object ); // 设置Replicator对应的ObjectNetGUID
 | | | | | | | | | |--// UNetDriver.GetReplicationChangeListMgr()
 | | | | | | | | | |--// 从NetDriver中提取出UObject对应的ChangelistMgr, 并赋值给FObjectReplicator.ChangelistMgr
 | | | | | | | | | |--ChangelistMgr = WorldNetDriver->GetReplicationChangeListMgr(Object);
 | | | | | | | | | | |--const TSharedPtr<const FRepLayout> RepLayout = GetObjectClassRepLayout(Object->GetClass());
 | | | | | | | | | | |--FReplicationChangelistMgrWrapper Wrapper(Object, RepLayout->CreateReplicationChangelistMgr(Object, GetCreateReplicationChangelistMgrFlags()));
 | | | | | | | | | | | |--FReplicationChangelistMgr.LastInitialReplicationFrame{ctor} // 在初始化列表中进行初始化
 | | | | | | | | | | | | |--FRepChangelistState::FRepChangelistState{ctor}// 初始化列表中进行初始化
 | | | | | | | | | | | | | |--FRepLayout.CreateShadowBuffer()
 | | | | | | | | | | | | | | |--FRepLayout.InitRepStateStaticBuffer()
 | | | | | | | | | | | | | | | |--ShadowData.Buffer.SetNumZeroed(ShadowDataBufferSize);
 | | | | | | | | | | | | | | | |--FRepLayout.ConstructProperties()
 | | | | | | | | | | | | | | | |--FRepLayout.CopyProperties()
 | | | | | | | | | | |--// 将新创建的FReplicationChangelistMgrWrapper放入UNetDriver.ReplicationChangeListMap中
 | | | | | | | | | | |--ReplicationChangeListMgrPtr = &ReplicationChangeListMap.Add(Object, Wrapper);
 | | | | | | |--UNetDriver.ProcessRemoteFunctionForChannelPrivate()
 | | | | | | | |--Ch->ReplicateActor();
 | | | | | | | | |--WroteSomethingImportant |= ActorReplicator->ReplicateProperties(Bunch, RepFlags);
 | | | | | | | | | |--FNetSerializeCB::UpdateChangelistMgr(*RepLayout, SendingRepState, *ChangelistMgr, Object, Connection->Driver->ReplicationFrame, RepFlags, OwningChannel->bForceCompareProperties || bUseCheckpointRepState);
 | | | | | | | | | | |--FRepLayout.UpdateChangelistMgr() 
 | | | | | | | | | | | |--FRepLayout.CompareProperties()
 | | | | | | | | | | | | |--RepChangelistState->CompareIndex++;
 | | | | | | | | | | | | |--
 | | | | | | | | | | | | |--
 | | | | | | | | | | | | |--
 | | | | | | | | | | | | |--
 | | | | | | | | | | | | |--
 | | | | | | | | | | | |--InChangelistMgr.LastReplicationFrame = ReplicationFrame;
 | | | | | | | | | | | |--if (GShareInitialCompareState && RepFlags.bNetInitial)
 | | | | | | | | | | | |--{
 | | | | | | | | | | | |--	InChangelistMgr.LastInitialReplicationFrame = ReplicationFrame;
 | | | | | | | | | | | |--}
 | | | | | | | | | | | |--
 | | | | | | | | | | | |--
 | | | | | | | | | | | |--
 | | | | | | | | | | | |--
 | | | | | | | | | | | |--
 | | | | | | | | | | | |--
 | | | | | | | | | |--ReplicateCustomDeltaProperties(Writer, RepFlags);






